<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>font</title>
</head>
<body>

<canvas id="canvas"></canvas>

<script>



function objOff(obj)
{
    var currleft = currtop = 0;
    if( obj.offsetParent )
    { do { currleft += obj.offsetLeft; currtop += obj.offsetTop; }
      while( obj = obj.offsetParent ); }
    else { currleft += obj.offsetLeft; currtop += obj.offsetTop; }
    return [currleft,currtop];
}

function FontMetric(fontName,fontSize,character)
{
    var text = document.createElement("span");
    text.style.fontFamily = fontName;
    text.style.fontSize = fontSize + "px";
    text.innerHTML = character;
    // if you will use some weird fonts, like handwriting or symbols, then you need to edit this test string for chars that will have most extreme accend/descend values

    console.log( "charCode", character.charCodeAt( 0 ) );

    var block = document.createElement("div");
    block.style.display = "inline-block";
    block.style.width = "1px";
    block.style.height = "0px";

    var div = document.createElement("div");
    div.appendChild(text);
    div.appendChild(block);

    // this test div must be visible otherwise offsetLeft/offsetTop will return 0
    // but still let's try to avoid any potential glitches in various browsers
    // by making it's height 0px, and overflow hidden
    div.style.height = "0px";
    div.style.overflow = "hidden";

    // I tried without adding it to body - won't work. So we gotta do this one.
    document.body.appendChild(div);

    block.style.verticalAlign = "baseline";
    var bp = objOff(block);
    var tp = objOff(text);
    var taccent = bp[1] - tp[1];
    block.style.verticalAlign = "bottom";
    bp = objOff(block);
    tp = objOff(text);
    var theight = bp[1] - tp[1];
    var tdescent = theight - taccent;

    // now take it off :-)
    document.body.removeChild(div);

    document.body.appendChild(text);

    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    ctx.font = fontSize + "px " + fontName;
    ctx.fillText( character, 50, 50 );
    var textMetric = ctx.measureText( character ); // TextMetrics object

    // return text accent, descent and total height
    return {
        "accent": taccent,
        "height": theight,
        "descent": tdescent,
        "width": textMetric.width
    };
}

console.log( FontMetric( "Lato Black", 32, "l" ) );


// ArialMT 64
// charCode 65
// { accent: 57, height: 73, descent: 16 }
// char id=65   x=733     y=421     width=61     height=63     xoffset=-8     yoffset=4    xadvance=43     page=0  chnl=0

// Lato Black 32
// charCode 65
// { accent: 32, height: 39, descent: 7, width: 23.58404541015625 }
// char id=65   x=0     y=109     width=33     height=34     xoffset=-4     yoffset=3    xadvance=24     page=0  chnl=0
// charCode 108
// { accent: 32, height: 39, descent: 7, width: 9.120025634765625 }
// char id=108   x=183     y=41     width=15     height=34     xoffset=-2     yoffset=3    xadvance=9     page=0  chnl=0

</script>


<script type="text/javascript">

    /*
     * Dynamic sprite atlas
     *
     * - Allocates variable-sized sprites in rows
     * - Will grow itself when full
     */

 if(false){

    Atlas = (function(superClass) {

      Atlas.prototype.shader = function(shader) {
        shader.pipe("map.2d.data", this.uniforms);
        shader.pipe("sample.2d", this.uniforms);
        if (this.channels < 4) {
          shader.pipe(Util.GLSL.swizzleVec4(['0000', 'x000', 'xw00', 'xyz0'][this.channels]));
        }
        return shader;
      };

      Atlas.prototype.resize = function(width, height) {
        if (!this.backed) {
          throw new Error("Cannot resize unbacked texture atlas");
        }
        if (width > 2048 && height > 2048) {
          console.warn("Giant text atlas " + width + "x" + height + ".");
        } else {
          console.info("Resizing text atlas " + width + "x" + height + ".");
        }
        this.texture.resize(width, height);
        this.width = width;
        this.height = height;
        return this.samples = width * height;
      };

      Atlas.prototype.collapse = function(row) {
        var rows;
        rows = this.rows;
        rows.splice(rows.indexOf(row), 1);
        this.bottom = rows[rows.length - 1].bottom;
        if (this.last === row) {
          return this.last = null;
        }
      };

      Atlas.prototype.allocate = function(key, width, height, emit) {
        var bottom, gap, h, i, index, j, len, max, ref, row, top, w;
        w = this.width;
        h = this.height;
        max = height * 2;
        if (width > w) {
          this.resize(w * 2, h * 2);
          this.last = null;
          return this.allocate(key, width, height, emit);
        }
        row = this.last;
        if (row != null) {
          if (row.height >= height && row.height < max && row.width + width <= w) {
            row.append(key, width, height, emit);
            return;
          }
        }
        bottom = 0;
        index = -1;
        top = 0;
        ref = this.rows;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          row = ref[i];
          gap = row.top - bottom;
          if (gap >= height && index < 0) {
            index = i;
            top = bottom;
          }
          bottom = row.bottom;
          if (row.height >= height && row.height < max && row.width + width <= w) {
            row.append(key, width, height, emit);
            this.last = row;
            return;
          }
        }
        if (index >= 0) {
          row = new Row(top, height);
          this.rows.splice(index, 0, row);
        } else {
          top = bottom;
          bottom += height;
          if (bottom >= h) {
            this.resize(w * 2, h * 2);
            this.last = null;
            return this.allocate(key, width, height, emit);
          }
          row = new Row(top, height);
          this.rows.push(row);
          this.bottom = bottom;
        }
        row.append(key, width, height, emit);
        this.last = row;
      };

      Atlas.prototype.read = function() {
        return this.texture.textureObject;
      };

      Atlas.prototype.write = function(data, x, y, w, h) {
        return this.texture.write(data, x, y, w, h);
      };

      Atlas.prototype.dispose = function() {
        this.texture.dispose();
        this.data = null;
        return Atlas.__super__.dispose.apply(this, arguments);
      };

      return Atlas;

    })(Renderable);

    Row = (function() {
      function Row(top, height) {
        this.top = top;
        this.bottom = top + height;
        this.width = 0;
        this.height = height;
        this.alive = 0;
        this.keys = [];
      }

      Row.prototype.append = function(key, width, height, emit) {
        var x, y;
        x = this.width;
        y = this.top;
        this.alive++;
        this.width += width;
        this.keys.push(key);
        return emit(this, x, y);
      };

      return Row;

    })();

    module.exports = Atlas;

}

</script>



<script type="text/javascript">


NGL = {};


/*
 * Dynamic text atlas
 * - Stores entire strings as sprites
 * - Renders alpha mask (fast) or signed distance field (slow)
 * - Emits (x,y,width,height) pointers into the atlas
 */

NGL.TextAtlas = function( params ){

    var p = Object.assign( {}, params );

    this.font = p.font !== undefined ? p.font : [ 'sans-serif' ];
    this.size = p.size || 24;
    this.style = p.style !== undefined ? p.style : 'normal';
    this.variant = p.variant !== undefined ? p.variant : 'normal';
    this.weight = p.weight !== undefined ? p.weight : 'normal';
    this.outline = p.outline !== undefined ? p.outline : 0;
    this.width = p.width || 1024;
    this.height = p.height || 1024;

    this.gamma = 0.5;
    if (typeof navigator !== 'undefined') {
        var ua = navigator.userAgent;
        if (ua.match(/Chrome/) && ua.match(/OS X/)) {
            this.gamma = 0.5;
        }
    }

    this.mapped = {};
    this.scratchW = 0;
    this.scratchH = 0;
    this.currentX = 0;
    this.currentY = 0;

    this.build( p );

}

NGL.TextAtlas.prototype = {

    build: function( params ){

        // Prepare line-height with room for outline and descenders/ascenders
        var lineHeight = this.size + 2 * this.outline + Math.round( this.size / 4 );
        var maxWidth = ( 512 / 16 ) * lineHeight;

        // Font string
        var quote = function(str) {
            return "\"" + ( str.replace( /(['"\\])/g, "\\$1" ) ) + "\"";
        };
        var font = this.font.map( quote ).join( ", " );

        // Prepare scratch canvas
        var canvas = document.createElement( "canvas" );
        canvas.width = maxWidth;
        canvas.height = lineHeight;
        var ctx = canvas.getContext( "2d" );
        ctx.font = this.style + " " + this.variant + " " + this.weight + " " + this.size + "px " + this.font;
        // ctx.fillStyle = "rgba(255,0,0,1.0)";
        ctx.textAlign = "left";
        ctx.textBaseline = "bottom";
        ctx.lineJoin = "round";
        ctx.globalAlpha = 1.0;

        // Prepare scratch canvas3
        var canvas3 = document.createElement( "canvas" );
        canvas3.width = maxWidth;
        canvas3.height = lineHeight;
        var ctx3 = canvas3.getContext( "2d" );
        ctx3.font = ctx.font;
        ctx3.textAlign = ctx.textAlign;
        ctx3.textBaseline = ctx.textBaseline;
        ctx3.lineJoin = ctx.lineJoin;
        ctx3.globalAlpha = ctx.globalAlpha;


        document.body.appendChild( canvas );
        canvas.setAttribute( "style", "position: absolute; top: 0; left: 0; z-index: 100; border: 1px solid red; background: rgba(255,0,255,.25);" );

        document.body.appendChild( canvas3 );
        canvas3.setAttribute( "style", "position: absolute; bottom: 0; left: 0; z-index: 100; border: 1px solid red; background: rgba(255,0,255,.25);" );

        var colors = [];
        var dilate = this.outline * 3;
        for( var i = 0; i < dilate; ++i ){
            // 8 rgb levels = 1 step = .5 pixel increase
            var val = Math.max( 0, -i * 8 + 128 - ( !i ) * 8 );
            console.log( val )
            var hex = ( "00" + val.toString( 16 ) ).slice( -2 );
            // colors.push( "#" + hex + hex + hex );
            colors.push( "rgba("+val+","+val+","+val+","+"1.0)" );
        }
        var scratch = new Uint8Array( maxWidth * lineHeight * 2 );
console.log( colors );
        this.canvas = canvas;
        this.context = ctx;
        this.context3 = ctx3;
        this.lineHeight = lineHeight;
        this.maxWidth = maxWidth;
        this.colors = colors;
        this.scratch = scratch;

        this.data = new Uint8Array( this.width * this.height * 4 );

        this.canvas2 = document.createElement( 'canvas' );
        this.canvas2.width = this.width;
        this.canvas2.height = this.height;
        this.context2 = this.canvas2.getContext( '2d' );
        this.context2.globalAlpha = 1.0;
        document.body.appendChild( this.canvas2 );
        this.canvas2.setAttribute( "style", "position: absolute; bottom: 0; right: 0; z-index: 100; border: 1px solid green; background: rgba(255,0,255,.25);" );

    },

    map: function( text ){

        if( this.mapped[ text ] === undefined ){

            this.draw( text );

            // ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);

            if( this.currentX + this.scratchW > this.width ){
                this.currentX = 0;
                this.currentY += this.scratchH;
            }
            if( this.currentY + this.scratchH > this.height ){
                console.warn( "canvas to small" );
            }

            this.mapped[ text ] = {
                x: this.currentX,
                y: this.currentY,
                w: this.scratchW,
                h: this.scratchH
            };

            this.context2.drawImage(
                this.canvas,
                0, 0,
                this.scratchW, this.scratchH,
                this.currentX, this.currentY,
                this.scratchW, this.scratchH
            );

            this.currentX += this.scratchW;

        }

        return this.mapped[ text ];

    },

    draw: function( text ){

        var w = this.width;
        var h = this.lineHeight;
        var o = this.outline;
        var ctx = this.context;
        var ctx3 = this.context3;
        var dst = this.scratch;
        var max = this.maxWidth;
        var colors = this.colors;

        // Bottom aligned, take outline into account
        var x = o;
        var y = h - this.outline;

        // Measure text
        var m = ctx.measureText( text );
        var w = Math.min( max, Math.ceil( m.width + 2 * x + 1 ) );

        // Clear scratch area
        ctx.clearRect(0, 0, w, h);
        ctx3.clearRect(0, 0, w, h);

        if( this.outline === 0 ){

            ctx.fillStyle = "rgba(255,0,0,1.0)";
            ctx.fillText( text, x, y );
            var imageData = ctx.getImageData( 0, 0, w, h );
            var data = imageData.data;

            var j = 3;  // Skip to alpha channel
            for( var i = 0, il = data.length / 4; i < il; ++i ){
                dst[ i ] = data[ j ];
                j += 4;
            }

        }else{

            ctx.globalCompositeOperation = "source-over";
            // Draw strokes of decreasing width to create
            // nested outlines (absolute distance)
            for( var i = o + 1; i > 0; --i ){
                // Eliminate odd strokes once past > 1px,
                // don't need the detail
                var j = i > 1 ? i * 2 - 2 : i;
                ctx.strokeStyle = colors[ j - 1 ];
                ctx.lineWidth = j;
                ctx.strokeText( text, x, y );
            }
            // var op = "multiply";
            // ctx.globalCompositeOperation = op;
            // if( ctx.globalCompositeOperation !== op ){
            //     console.log( "globalCompositeOperation '" + op + "' not supported" );
            // }
            ctx3.fillStyle = "rgba(255,0,0,1.0)";//"#FF00FF";
            ctx3.fillText( text, x, y );
            var imageData3 = ctx3.getImageData( 0, 0, w, h );
            var data3 = imageData3.data;

            var imageData = ctx.getImageData( 0, 0, w, h );
            var data = imageData.data;
            console.log( "imageData.data.length", imageData.data.length, w, h, w*h*4 )

            var j = 0;
            var gamma = this.gamma;
            function multiply( s, d ){
                return Math.round( ( ( s / 255 ) * ( d / 255 ) ) * 255 );
            }
            for( var i = 0, il = data.length / 4; i < il; ++i ){
                // Get value + mask
                var a = multiply( data3[ j ], data[ j ] ) + data[ j ];
                //a = 0;
                console.log(a)
                var mask = a ? multiply( data3[ j + 1 ], data[ j + 1 ] ) / a : 1;
                if( gamma === 0.5 ){
                    mask = Math.sqrt( mask );
                }
                mask = Math.min( 1, Math.max( 0, mask ) );

                // Blend between positive/outside and negative/inside
                var b = 256 - a;
                var c = b + ( a - b ) * mask;

                // Clamp (slight expansion to hide errors around the transition)
                dst[ i ] = Math.max( 0, Math.min( 255, c + 2 ) );
                data[ j     ] = dst[ i ];
                data[ j + 1 ] = dst[ i ];
                data[ j + 2 ] = dst[ i ];
                //data[ j + 3 ] = dst[ i ];
                j += 4;
            }

        }

        ctx.putImageData( imageData, 0, 0 );
        this.scratchW = w;
        this.scratchH = h;

    }

};

</script>


<script type="text/javascript">

console.time( "init" )
var ta = new NGL.TextAtlas( {
    // font: [ "Lato Black" ],
    font: [ "Monospace" ],
    outline: 5,
    size: 96
} );
console.timeEnd( "init" )


// console.time( "draw all" )
// for( var i = 0; i < 256; ++i ){
//     // console.log( i, String.fromCharCode( i ) );
//     ta.draw( String.fromCharCode( i ) );
// }
// console.timeEnd( "draw all" )

// console.time( "draw" )
// ta.draw( "@Am!gqÄÖß12379" );
// console.timeEnd( "draw" )

console.time( "map" )
ta.map( "@" );
console.timeEnd( "map" )

// var s = "moÄÄ?ßNmdsianOnsapmMLL";
// for( var i = 0, il = s.length; i < il; ++i ){
//     ta.map( s[ i ] );
// }

// console.time( "map all" )
// for( var i = 0; i < 256; ++i ){
//     // console.log( i, String.fromCharCode( i ) );
//     ta.map( String.fromCharCode( i ) );
// }
// console.timeEnd( "map all" )

</script>


</body>
</html>